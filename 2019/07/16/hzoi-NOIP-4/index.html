<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>衡中NOIP模拟赛4 | Gekoo&#39;s Notebook</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我好菜…">
<meta name="keywords" content="Tarjan,期望DP,比赛,状压,贪心,分治">
<meta property="og:type" content="article">
<meta property="og:title" content="衡中NOIP模拟赛4">
<meta property="og:url" content="https://gekoo.xyz/2019/07/16/hzoi-NOIP-4/index.html">
<meta property="og:site_name" content="Gekoo&#39;s Notebook">
<meta property="og:description" content="我好菜…">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-07-17T09:03:25.455Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="衡中NOIP模拟赛4">
<meta name="twitter:description" content="我好菜…">
  
  
    <link rel="icon" href="/pics/favicon.ico">
  
  
 <link href="https://fonts.googleapis.com/css?family=Open+Sans:400italic,400,600" rel="stylesheet" type="text/css">
 <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">


  <link rel="stylesheet" href="/css/style.css">
  <link rel="stylesheet" href="/font-awesome/css/font-awesome.min.css">
  

  

  
</head></html>
<body>
  <div id="container">
    <header id="header">
  <div id="header-main" class="header-inner">
    <div class="outer">
      <a href="/" id="logo"><i class="logo" style="background-image: url(/pics/site_logo.png)"></i><span class="site-title">Gekoo&#39;s Notebook</span></a>
      <nav id="main-nav">
        
      </nav>
      
      <div id="search-form-wrap">
        
          <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit"> </button><input type="hidden" name="sitesearch" value="https://gekoo.xyz"></form>
        
      </div>
    </div>
  </div>
  <div id="main-nav-mobile" class="header-sub header-inner">
    <table class="menu outer">
      <tr>
        
        <td>
          
            <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><input type="hidden" name="sitesearch" value="https://gekoo.xyz"></form>
          
        </td>
      </tr>
    </table>
  </div>
</header>

    <div class="outer">
      
      <section id="main"><article id="post-hzoi-NOIP-4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      衡中NOIP模拟赛4
    </h1>
  

        <div class="article-meta">
          
  <div class="article-date">
    <i class="fa fa-calendar"></i>
    <a href="/2019/07/16/hzoi-NOIP-4/">
      <time datetime="2019-07-16T15:41:35.000Z" itemprop="datePublished">2019-07-16</time>
    </a>
  </div>


          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
                
        <p>我好菜…</p>
<a id="more"></a>
<h1 id="T1-礼物"><a href="#T1-礼物" class="headerlink" title="T1:礼物"></a>T1:礼物</h1><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p><del>不是粉切黑吗</del></p>
<p>第一问答案和概率没啥关系，把喜悦加起来就行了</p>
<p>礼物最多20个，考虑状压，用集合S表示当前选择礼物的情况</p>
<p>每个S状态都有可能从S状态扣掉一个礼物的状态或者是没有拿到礼物的状态转移来，所以列出方程：</p>
<p>$f[S] = \sum f[S^{‘}] \times p_i +(1-\sum p_i) * f[S] + 1$</p>
<p>左右两边都有$f[S]$，再化简一下：</p>
<p>$f[S] = \frac{\sum f[S^{‘}] \times p_i + 1}{\sum p_i}$.</p>
<p><del>记得开longlong（小声</del></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> w[<span class="number">25</span>], ans;</span><br><span class="line"><span class="keyword">double</span> p[<span class="number">25</span>], f[<span class="number">1</span> &lt;&lt; <span class="number">21</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%lf%lld"</span>, &amp;p[i], &amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans += w[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> S = <span class="number">1</span>; S &lt;= (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; S++) &#123;</span><br><span class="line">        <span class="keyword">double</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> ((<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)) &amp; S)</span><br><span class="line">                f[S] += f[S ^ (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>))] * p[i], tmp += p[i];</span><br><span class="line">        f[S] = (f[S] + <span class="number">1</span>) / tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">printf</span>(<span class="string">"%lld\n%.3lf\n"</span>, ans, f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="T2-通讯"><a href="#T2-通讯" class="headerlink" title="T2:通讯"></a>T2:通讯</h1><p>如果两个部门可以直接或间接地相互传递消息忽略花费，等价于同一scc内的边权忽略，于是跑一遍Tarjan，缩点建新图。</p>
<p>最后我们得到一个DAG，答案是这张图的最小树形图。（但在考场上我其实还不知道这个概念</p>
<p>为了保证连通性，每个点都必须有一条入边。这时便可以贪心，我们的答案就是每个点入边的最小值之和。</p>
<p>这样算出来的答案肯定是最小的，可我们还要考虑最后的图是否连通。由于这张图有一个入度为0的“总部”，我们可以把它理解为类似于源点的东西，这样，我们每个点通过入边连到上一个点，不断向上，只要我们不停止，通往原点的道路就会不断延伸<del>所以不要停下来啊</del>，最后一定会汇到原点，因此这样选边出来的图一定联通。</p>
<p>事实上这就是求最小树形图的朱刘算法的一部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50000</span> + <span class="number">233</span>, M = <span class="number">500000</span> + <span class="number">233</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="keyword">int</span> to, nxt, val;&#125; e[M], c[M];</span><br><span class="line"><span class="keyword">int</span> ecnt, ccnt, head[N], hc[N], n = <span class="number">1</span>, m = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddEdge</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> to, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    e[++ecnt] = &#123;to, head[f], val&#125;, head[f] = ecnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">AddC</span><span class="params">(<span class="keyword">int</span> f, <span class="keyword">int</span> to, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    c[++ccnt] = &#123;to, hc[f], val&#125;, hc[f] = ccnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dfn[N], low[N], stk[N], id[N], p, num, scc;</span><br><span class="line"><span class="keyword">bool</span> ins[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    stk[++p] = x, ins[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = e[i].to; i; i = e[i].nxt, y = e[i].to) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[y])</span><br><span class="line">            Tarjan(y), low[x] = <span class="built_in">std</span>::min(low[x], low[y]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ins[y]) low[x] = <span class="built_in">std</span>::min(low[x], dfn[y]);</span><br><span class="line">    &#125; <span class="keyword">if</span> (low[x] == dfn[x]) &#123;</span><br><span class="line">        ++scc; <span class="keyword">int</span> z;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            z = stk[p--], ins[z] = <span class="number">0</span>, id[z] = scc;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != z);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">0</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line">    <span class="built_in">memset</span>(id, <span class="number">0</span>, <span class="keyword">sizeof</span>(id));</span><br><span class="line">    <span class="built_in">memset</span>(ins, <span class="number">0</span>, <span class="keyword">sizeof</span>(ins));</span><br><span class="line">    <span class="built_in">memset</span>(hc, <span class="number">0</span>, <span class="keyword">sizeof</span>(hc));</span><br><span class="line">    ecnt = p = num = scc = ccnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m); </span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span> &amp;&amp; m == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y, z; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;x, &amp;y, &amp;z);      </span><br><span class="line">            AddEdge(x + <span class="number">1</span>, y + <span class="number">1</span>, z);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span> (!dfn[i]) Tarjan(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= n; x++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y = e[i].to; i; i = e[i].nxt, y = e[i].to)</span><br><span class="line">                <span class="keyword">if</span> (id[x] != id[y])</span><br><span class="line">                    AddC(id[y], id[x], e[i].val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">1</span>; x &lt;= scc; x++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = hc[x]; i; i = c[i].nxt)</span><br><span class="line">                tmp = <span class="built_in">std</span>::min(tmp, c[i].val);</span><br><span class="line">            ans += tmp != <span class="number">0x3f3f3f3f</span> ? tmp : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">        clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="T3-奇袭"><a href="#T3-奇袭" class="headerlink" title="T3:奇袭"></a>T3:奇袭</h1><p>考场糊了个$O(n^2)$暴力，正解没码完。。。（手速堪忧</p>
<h3 id="30分做法"><a href="#30分做法" class="headerlink" title="30分做法"></a>30分做法</h3><p>$O(n^3)$，应该是二维前缀和？我不知道，没咋想（</p>
<h3 id="60分做法"><a href="#60分做法" class="headerlink" title="60分做法"></a>60分做法</h3><p>$O(n^2)$<del>出题人咋没想到做法啊（</del>。</p>
<p>首先每一个Xi和每一个Yi都是不一样的，可以想到每一行都能对应到唯一的一列，这时我们就可以降维，每一个矩形可以对应到这个序列的子序列。</p>
<p>现在问题就是怎么判定这个矩形是正方形，可以想到子序列中最大值和最小值的差就是这个矩形的一条边长，子序列的左右端点之差是另一条边长。</p>
<p>判断这个矩形是否为正方形，只需判断$r - l = max - min$.</p>
<p>枚举l和r，逐一判断是否符合等式。</p>
<h3 id="100分做法"><a href="#100分做法" class="headerlink" title="100分做法"></a>100分做法</h3><p>看数据范围大约是$O(nlogn)$.我们要在60分做法的基础上继续加以改进。</p>
<p>核心思想还是$r - l = max - min$这个式子。主要思路是分类讨论，用桶统计结果。</p>
<p>求出mid，有四种情况：</p>
<ol>
<li>最大值在左，最小值在右</li>
<li>最小值在左，最大值在右</li>
<li>最大值最小值都在左</li>
<li>最大值最小值都在右</li>
</ol>
<p>12和34是对称的，只须考虑1和3。</p>
<p><del>于是这里就出现了骚操作，可以使用std::reverse,就真-只考虑1和3了，大幅减少码长</del></p>
<h4 id="case-1"><a href="#case-1" class="headerlink" title="case 1:"></a>case 1:</h4><p>我懒得画图了，请自行画图（</p>
<p>首先预处理出来4个数组,mid向左的后缀最大值Lmax,后缀最小值Lmin，向右同理</p>
<p>设i为矩形左端点，j为右端点。</p>
<p>此时$Lmax[i] - Rmin[j] = j - i$，移项，$j + Rmin[j] = i + Lmax[i]$, 我们把i + Lmax[i]和j + Rmin[j]作为桶的下标。</p>
<p>同时$Lmax[i] &gt;= Rmax[j]，Lmin[i] &gt;= Rmin[j]$.</p>
<p>我们从分治区间左端点L到mid枚举左端点i，易于想到在右边j可能存在在一个区间$[p, q]$内使得原式成立（Rmax和Rmin可能在某一段是不变的）。</p>
<p>我们这时用桶统计，设桶名为QAQ。先移动右端点q。while (Rmax[q] &lt; Lmax[i])，QAQ[q + Rmin[q]]++, 同时将也q++。这样将所有满足第一个不等式的结果都扔进桶里。之后再移动左端点p，while (Rmin[p] &gt; Lmin[i])，QAQ[p + Rmin[p]]—, 之后再把p++，这一步又将所有不满足第二个不等式的结果从桶里扔出来了。</p>
<p>最后答案应该加上QAQ<a href="如果&gt;0的话">i + Lmax[i]</a>.把桶清空一下。</p>
<h4 id="case-3"><a href="#case-3" class="headerlink" title="case 3:"></a>case 3:</h4><p>套用原式可以把j的位置直接算出来，直接判断是否合法，把合法答案加给ans。</p>
<h4 id="case-2-amp-4"><a href="#case-2-amp-4" class="headerlink" title="case 2 &amp; 4:"></a>case 2 &amp; 4:</h4><p>与case 1 &amp; 3对称，自己想去（</p>
<p>有个坑：减的时候桶的下标可能会小于0，这个时候在这种情况的每个下标都加一个偏移量delta就行了。</p>
<h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> n, a[<span class="number">50005</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        a[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> mx = a[i], mn = a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n; j++) &#123;</span><br><span class="line">            mx = <span class="built_in">std</span>::max(mx, a[j]), mn = <span class="built_in">std</span>::min(mn, a[j]);</span><br><span class="line">            <span class="keyword">if</span> (mx - mn == j - i) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//O(n^2)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">50005</span>, delta = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[N], Lmx[N], Lmn[N], Rmx[N], Rmn[N], QAQ[N &lt;&lt; <span class="number">3</span>];</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Gekoo</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123; <span class="comment">//分治</span></span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; ++ans; <span class="keyword">return</span>; &#125; <span class="comment">//l,r相等直接ans++</span></span><br><span class="line">    <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; i++) Lmx[i] = Rmx[i] = <span class="number">-0x3f3f3f3f</span>, Lmn[i] = Rmn[i] = <span class="number">0x3f3f3f3f</span>; <span class="comment">//预处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= L; i--) Lmx[i] = <span class="built_in">std</span>::max(Lmx[i + <span class="number">1</span>], a[i]), Lmn[i] = <span class="built_in">std</span>::min(Lmn[i + <span class="number">1</span>], a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= R; i++) Rmx[i] = <span class="built_in">std</span>::max(Rmx[i - <span class="number">1</span>], a[i]), Rmn[i] = <span class="built_in">std</span>::min(Rmn[i - <span class="number">1</span>], a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= L; i--) &#123; <span class="comment">//最大最小值都在左侧</span></span><br><span class="line">        <span class="keyword">int</span> pos = Lmx[i] - Lmn[i] + i;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; mid &amp;&amp; pos &lt;= R &amp;&amp; Lmx[i] &gt;= Rmx[pos] &amp;&amp; Lmn[i] &lt;= Rmn[pos]) ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= R; i++) &#123; <span class="comment">//最大最小值都在右侧</span></span><br><span class="line">        <span class="keyword">int</span> pos = Rmn[i] - Rmx[i] + i;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid &amp;&amp; pos &gt;= L &amp;&amp; Rmx[i] &gt;= Lmx[pos] &amp;&amp; Lmn[pos] &gt;= Rmn[i]) ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> p = mid + <span class="number">1</span>, q = mid + <span class="number">1</span>; <span class="comment">//最大在左,最小在右</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid; i &gt;= L; i--) &#123;</span><br><span class="line">        <span class="keyword">while</span> (q &lt;= R &amp;&amp; Lmx[i] &gt;= Rmx[q])</span><br><span class="line">            QAQ[q + Rmn[q]]++, q++;</span><br><span class="line">        <span class="keyword">while</span> (p &lt;= R &amp;&amp; Lmn[i] &lt; Rmn[p])</span><br><span class="line">            QAQ[p + Rmn[p]]--, p++;</span><br><span class="line">        <span class="keyword">if</span> (QAQ[i + Lmx[i]] &gt; <span class="number">0</span>) ans += QAQ[i + Lmx[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= R; i++) QAQ[i + Rmn[i]] = <span class="number">0</span>;<span class="comment">//清空桶</span></span><br><span class="line"></span><br><span class="line">    p = q = mid; <span class="comment">//最小在左,最大在右</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= R; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (p &gt;= L &amp;&amp; Rmx[i] &gt;= Lmx[p])</span><br><span class="line">            QAQ[Lmn[p] - p + delta]++, p--;</span><br><span class="line">        <span class="keyword">while</span> (q &gt;= L &amp;&amp; Rmn[i] &lt; Lmn[q])</span><br><span class="line">            QAQ[Lmn[q] - q + delta]--, q--;</span><br><span class="line">        <span class="keyword">if</span> (QAQ[Rmx[i] - i + delta] &gt; <span class="number">0</span>) ans += QAQ[Rmx[i] - i + delta];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= mid; i++) QAQ[Lmn[i] - i + delta] = <span class="number">0</span>;</span><br><span class="line">    Gekoo(L, mid), Gekoo(mid + <span class="number">1</span>, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, x, y; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span><br><span class="line">        a[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    Gekoo(<span class="number">1</span>, n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//nlogn</span></span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://gekoo.xyz/2019/07/16/hzoi-NOIP-4/" data-id="cjy8bjun0009qn8f2azxolj6l" class="article-share-link">分享到</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Tarjan/">Tarjan</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/分治/">分治</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/期望DP/">期望DP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/比赛/">比赛</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/状压/">状压</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/贪心/">贪心</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/07/17/luogu-p2015/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          Luogu P2015 二叉苹果树
        
      </div>
    </a>
  
  
    <a href="/2019/07/16/bzoj-3033/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">BZOJ 3033 太鼓达人</div>
    </a>
  
</nav>


  
</article>


</section>
      
        <aside id="sidebar">
  
    
  
    
  
    
  
    
  
    
  
    
  
  <div id="toTop" class="fa fa-chevron-up"></div>
</aside>
      
    </div>
    <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Gekoo<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>. Theme by <a href="http://github.com/ppoffice">PPOffice</a>
    </div>
  </div>
</footer>
    





 <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>





<script src="/js/script.js"></script>

  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
</body>
</html>